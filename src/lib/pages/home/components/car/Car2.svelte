<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 .\car.glb -T --draco /draco/
-->

<script lang="ts">
  import { type RigidBody as RapierRigidBody } from "@dimforge/rapier3d-compat";

  import { T, useTask, useThrelte } from "@threlte/core";
  import { MeshLineMaterial, useDraco, useGltf } from "@threlte/extras";
  import { Group, Vector3 } from "three";
  import { Collider, RigidBody } from "@threlte/rapier";
  import {
    keys,
    gameState,
    gameActions,
    isInVehicle,
    currentVehicle,
  } from "../../stores/stores";

  import {
    AddEquation,
    BufferGeometry,
    CustomBlending,
    OneFactor,
    Shape,
  } from "three";
  import { ThirdPersonControls } from "../controls/thirdPersonControls";
  import { createCustomExtrudedGeometry } from "./Nitro";

  let {
    cameraRef,
    position,
    rotation,
    color,
    isTransitioning = false,
    fallback = () => {},
    error = () => {},
    children = () => {},
    ref = $bindable(),
    ...props
  } = $props();

  const { camera } = useThrelte();
  const gltf = useGltf("/car-transformed.glb", { dracoLoader: useDraco() });

  let geometry: BufferGeometry | undefined = $state<BufferGeometry>();

  const shape = new Shape();
  shape.moveTo(0, 0.2);
  shape.lineTo(-0.5, -0.35);
  shape.lineTo(0.5, -0.35);
  shape.lineTo(0, 0.2);

  geometry = createCustomExtrudedGeometry(shape, 2, 0);

  const v3 = new Vector3();
  const carId = crypto.randomUUID();

  let mainGroupRef: Group | undefined = $state<Group>();
  let rigidBody: RapierRigidBody | undefined = $state<RapierRigidBody>();
  let objectRef: Group | undefined = $state<Group>();
  let controls: ThirdPersonControls | undefined;
  let vehicleRegistered = false;

  // Variables for speedometer and nitro
  let currentSpeed = $state(0);
  let nitroLevel = $state(100);
  let isNitroActive = $state(false);
  let nitroRegenTimer = 0;
  let nitroBlocked = $state(false); // New variable to block nitro

  // State to control if this vehicle is active
  let isActiveVehicle = $derived($isInVehicle && $currentVehicle?.id === carId);

  $effect(() => {
    if (objectRef && cameraRef && mainGroupRef) {
      const isTouchDevice = "ontouchstart" in window;
      const canvas = document.querySelector("canvas");

      //@ts-ignore
      controls = new ThirdPersonControls($camera, mainGroupRef, {
        offset: new Vector3(0, 1, 0),
        targetRadius: 10,
      });

      if (!isTouchDevice && canvas) {
        canvas.addEventListener("click", () => {
          if (document.pointerLockElement !== canvas) {
            canvas.requestPointerLock();
          }
        });

        canvas.addEventListener("pointermove", (e) => {
          if (document.pointerLockElement === canvas && isActiveVehicle && !isTransitioning) {
            controls?.update(e.movementX * 2, e.movementY * 2);
          }
        });
      }
    }
  });

  useTask((delta) => {
    if (!rigidBody || !objectRef || !cameraRef || !controls) return;

    // Register the vehicle once everything is ready
    if (!vehicleRegistered && mainGroupRef) {
      console.log("Registering vehicle with ID:", carId);
      gameActions.registerVehicle({
        id: carId,
        reference: mainGroupRef,
        position: position,
        rotation: rotation || [0, 0, 0],
        type: "car"
      });
      vehicleRegistered = true;
    }

    // Only process controls if this vehicle is active and there's no transition
    if (!isActiveVehicle || isTransitioning) return;

    const cameraDirection = cameraRef.getWorldDirection(v3);
    const thetaCamera = Math.atan2(cameraDirection.x, cameraDirection.z);
    const objectDirection = objectRef.getWorldDirection(v3);
    const thetaObject = Math.atan2(objectDirection.x, objectDirection.z);

    let deltaTheta = thetaCamera - thetaObject;
    if (deltaTheta > Math.PI) deltaTheta -= Math.PI * 2;
    if (deltaTheta < -Math.PI) deltaTheta += Math.PI * 2;

    const rotationSpeed = 10;
    const angularVelocityY = deltaTheta * rotationSpeed;
    const maxAngularVelocity = 15;
    const clampedAngularVelocity =
      Math.sign(angularVelocityY) *
      Math.min(Math.abs(angularVelocityY), maxAngularVelocity);

    rigidBody.setAngvel({ x: 0, y: clampedAngularVelocity, z: 0 }, true);

    const pos = rigidBody.translation();
    position = [pos.x, pos.y, pos.z];

    // Update vehicle position in global state
    gameActions.updateVehiclePosition(carId, position);

    let currentVelocity = 0;
    let reverseVelocity = 0;

    // Calculate current speed for speedometer
    const velocity = rigidBody.linvel();
    const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
    currentSpeed = speed * 3.6; // Convert m/s to km/h

    // Improved Nitro system with blocking
    // If nitro is completely depleted, block it until it regenerates a bit
    if (nitroLevel <= 0 && !nitroBlocked) {
      nitroBlocked = true;
      console.log("Nitro blocked - completely depleted");
    }
    
    // Unblock nitro when it has regenerated at least 20%
    if (nitroBlocked && nitroLevel >= 20) {
      nitroBlocked = false;
      console.log("Nitro unblocked - sufficiently regenerated");
    }

    // Only allow nitro if not blocked, there's nitro available and shift is pressed
    isNitroActive = $keys.shift.isPressed && nitroLevel > 0 && !nitroBlocked;
    
    if (isNitroActive && ($keys.w.isPressed || $keys.s.isPressed)) {
      // Consume nitro
      nitroLevel = Math.max(0, nitroLevel - delta * 30); // Consumes 30% per second
      nitroRegenTimer = 0; // Reset regeneration timer
    } else {
      // Regenerate nitro after 2 seconds without using
      nitroRegenTimer += delta;
      if (nitroRegenTimer > 2 && nitroLevel < 100) {
        nitroLevel = Math.min(100, nitroLevel + delta * 20); // Regenerates 20% per second
      }
    }

    // Update vehicle data in store for UI
    gameActions.updateVehicleData(currentSpeed, nitroLevel, isNitroActive, nitroBlocked);

    // Movement with nitro
    if ($keys.w.isPressed && isNitroActive && nitroLevel > 0) {
      currentVelocity = 20; // Speed with nitro
    } else if ($keys.w.isPressed && $keys.shift.isPressed) {
      currentVelocity = 15; // Normal speed with shift
    } else if ($keys.w.isPressed) {
      currentVelocity = 8; // Normal speed
    } else if ($keys.s.isPressed) {
      reverseVelocity = -5; // Reverse
    }

    const totalVelocity = currentVelocity + reverseVelocity;

    if (totalVelocity != 0) {
      const x = Math.sin(thetaCamera) * totalVelocity;
      const z = Math.cos(thetaCamera) * totalVelocity;
      rigidBody.setLinvel({ x, y: 0, z }, true);
    } else {
      const currentVel = rigidBody.linvel();
      rigidBody.setLinvel(
        {
          x: currentVel.x * 0.9,
          y: currentVel.y,
          z: currentVel.z * 0.9,
        },
        true
      );
    }

    // Only update controls if there's no transition
    if (!isTransitioning) {
      controls.update(0, 0);
    }
  });

</script>

<T.Group bind:ref dispose={false} {...props}>
  {#await gltf}
    {@render fallback?.()}
  {:then gltf}
    <T.Group
      name="Car"
      {position}
      {rotation}
      bind:ref={mainGroupRef}
      dispose={false}
    >
      <RigidBody bind:rigidBody enabledRotations={[false, true, false]}>
        <Collider shape="cuboid" args={[1, 0.5, 2]}>
          <T.Group position={[0, -0.5, -0.4]} bind:ref={objectRef}>
            <T.Mesh
              {geometry}
              position={[0, 1.35, -1]}
              rotation={[0, Math.PI, 0]}
            >
              <T.MeshBasicMaterial
                color={isNitroActive ? "blue" : nitroBlocked ? "gray" : "red"}
                transparent={true}
                opacity={isNitroActive ? 0.8 : nitroBlocked ? 0.3 : 0.5}
                blending={CustomBlending}
                blendDst={OneFactor}
                blendEquation={AddEquation}
              />
            </T.Mesh>

            <T.Mesh
              geometry={gltf.nodes.car.geometry}
              material={gltf.materials["Material.002"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial {color} linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.glass.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="white" linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.side_light.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="cyan" linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.front_light.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="purple" linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.stop_light_1.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="orange" linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.nitro.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color={isNitroActive ? "#00ffff" : nitroBlocked ? "#666666" : "#6355df"} linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.stop_light_2.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="orange" linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.stop_light_3.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="red" linewidth={0.1} />
            </T.Mesh>
            <T.Mesh
              geometry={gltf.nodes.plate.geometry}
              material={gltf.materials["FrontColor.001"]}
              position={[0, 0.84, 0]}
              rotation={[Math.PI / 2, 0, 0]}
            >
              <MeshLineMaterial color="#6355df" linewidth={0.1} />
            </T.Mesh>
          </T.Group>
        </Collider>
      </RigidBody>
    </T.Group>
  {:catch err}
    {@render error?.({ error: err })}
  {/await}

  {@render children?.({ ref })}
</T.Group>